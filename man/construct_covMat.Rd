% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/construct_covMat.r
\name{construct_covMat}
\alias{construct_covMat}
\title{Construct Structured Covariance or Correlation Matrices (non-random)}
\usage{
construct_covMat(
  dim,
  corr = FALSE,
  type = "diag",
  params = list(),
  eigen_check = TRUE
)
}
\arguments{
\item{dim}{Integer. Dimension of the resulting matrix.}

\item{corr}{Logical. If \code{TRUE}, returns a correlation matrix.
If \code{FALSE} (default), returns a covariance matrix scaled by \code{variances}.
For types \code{factor} and \code{graph}, \code{variances} are ignored.}

\item{type}{Character. Structure type of the covariance/correlation matrix. Supported values:
\describe{
\item{\code{"diag"}}{Diagonal matrix (identity correlation).}
\item{\code{"CS"}}{Compound symmetry (exchangeable correlation).}
\item{\code{"block"}}{Block-diagonal matrix.}
\item{\code{"toeplitz"}}{Toeplitz matrix with lag correlations (AR(1) structure).}
\item{\code{"AR"}}{Autoregressive AR(p) process.}
\item{\code{"MA"}}{Moving average MA(q) process.}
\item{\code{"ARMA"}}{ARMA(p, q) process.}
\item{\code{"ARIMA"}}{ARIMA(p, d, q) process.}
\item{\code{"SAR"}}{Seasonal AR process.}
\item{\code{"SMA"}}{Seasonal MA process.}
\item{\code{"SARMA"}}{Seasonal ARMA process.}
\item{\code{"SARIMA"}}{Seasonal ARIMA process.}
\item{\code{"factor"}}{Factor model: loadings + uniquenesses.}
\item{\code{"graph"}}{Graph-structured precision matrix (GMRF-style).
Uses precision = adjacency + diagonal dominance; covariance = inverse of precision.}
\item{\code{"spatial"}}{Spatial correlation via a distance matrix and kernel function.}
\item{\code{"specConstr"}}{Spectrum-constrained matrix with specified eigenvalues, rank or condition number.}
}}

\item{params}{Named list of parameters required for the selected type. Common parameters:
\describe{
\item{\code{variances}}{Numeric scalar or vector; used if \code{corr = FALSE} and \code{type} is neither \code{factor} nor \code{graph}.
Defaults to 1.}
\item{\code{rho}}{Numeric scalar, vector, or matrix/list. Correlation parameter(s)}
\item{\code{groups}}{Vector of group sizes for block-diagonal matrices.}
\item{\code{arma_phi}, \code{arma_theta}}{AR and MA coefficients for time series types.}
\item{\code{d}}{Differencing order for ARIMA/SARIMA processes.}
\item{\code{D}, \code{seasonal_period}}{Seasonal differencing order and period for SARIMA/SARMA/SMA/SAR processes.}
\item{\code{seasonal_phi}, \code{seasonal_theta}}{Seasonal AR/MA coefficients.}
\item{\code{loadings}, \code{psi}}{Factor loadings and uniquenesses for factor models.}
\item{\code{adjacency}}{Symmetric adjacency matrix for graph-based covariance.}
\item{\code{distances}}{Distance matrix for spatial correlation. Defaults to absolute differences.}
\item{\code{kernel}}{Kernel function for spatial correlation.
Can be a function or one of: \code{"exponential"}, \code{"gaussian"}, \code{"matern"}, \code{"rational_quadratic"},
\code{"powered_exponential"}, \code{"cauchy"}.}
\item{\code{phi}, \code{nu}, \code{alpha}, \code{beta}, \code{power}}{Spatial kernel parameters.}
\item{\code{eigenvalues}, \code{rank}, \code{cond_num}}{Parameters for spectrum-constrained matrices.
Specified eigenvalues, rank and condition numbers respectively.}
\item{bandwidth}{Integer; optional for CS or Toeplitz matrices to zero out entries beyond a certain lag.}
\item{max_iter, tol}{Maximum iterations and tolerance for spectrum-constrained iterative projections. See Details.}
}}

\item{eigen_check}{Logical. If \code{TRUE} (default), checks if the resulting matrix is PSD/PD.}
}
\value{
A symmetric \code{dim} \eqn{\times} \code{dim} matrix of class \code{covMat}. Either correlation or covariance depending on \code{corr}.
}
\description{
Constructs a \eqn{dim \times dim} covariance or correlation matrix according to a specified structural type.
Supported types include diagonal, compound symmetry, block, Toeplitz, autoregressive/moving-average processes
(AR/MA/ARMA/ARIMA), factor models, graph-based precision structures, spatial kernels, and spectrum-constrained matrices.
}
\details{
The \code{params} list must contain type-specific elements as follows:
\describe{
\item{"diag"}{Optional: \code{variances} (numeric vector or scalar) if \code{corr = FALSE}. Defaults to 1.}
\item{"CS"}{\code{rho} (scalar correlation), optional \code{variances} (if \code{corr = FALSE}), optional \code{bandwidth}.}
\item{"block"}{\code{groups} (vector of integers specifying block sizes), \code{rho} (scalar or vector for each block), optional \code{variances}.}
\item{"toeplitz"}{\code{rho} (vector or scalar), optional \code{variances}, optional \code{bandwidth}.}
\item{"AR"}{\code{arma_phi} (AR coefficients), optional \code{variances}.}
\item{"MA"}{\code{arma_theta} (MA coefficients), optional \code{variances}.}
\item{"ARMA"}{\code{arma_phi} (AR coefficients), \code{arma_theta} (MA coefficients), optional \code{variances}.}
\item{"ARIMA"}{\code{arma_phi} (AR), \code{arma_theta} (MA), \code{d} (differencing order), optional \code{variances}.}
\item{"SAR"}{\code{seasonal_phi} (seasonal AR), \code{D} (seasonal differencing), \code{seasonal_period}.}
\item{"SMA"}{\code{seasonal_theta} (seasonal MA), \code{D}, \code{seasonal_period}.}
\item{"SARMA"}{\code{seasonal_phi}, \code{seasonal_theta}, \code{D}, \code{seasonal_period}.}
\item{"SARIMA"}{\code{arma_phi}, \code{arma_theta}, \code{d}, \code{seasonal_phi}, \code{seasonal_theta}, \code{D}, \code{seasonal_period}.}
\item{"factor"}{\code{loadings} (matrix \code{dim} \eqn{\times} \code{k}), \code{psi} (vector of uniquenesses length dim).}
\item{"graph"}{\code{adjacency} (symmetric matrix \code{dim} \eqn{\times} \code{dim}).}
\item{"spatial"}{\code{distances} (\code{dim} \eqn{\times} \code{dim} matrix), \code{kernel} (function or string: \code{"exponential"}, \code{"gaussian"}, \code{"matern"}, \code{"rational_quadratic"}, \code{"powered_exponential"}, \code{"cauchy"}), kernel-specific parameters (\code{phi}, \code{nu}, \code{alpha}, \code{beta}, \code{power}).}
\item{"specConstr"}{\code{eigenvalues} (numeric vector), \code{rank} (integer <= \code{dim}), \code{cond_num} (numeric), optional \code{max_iter} and \code{tol}.}
}

\strong{Time series types:}
Non-stationary models use MA(\eqn{\infty}) expansion with differencing.
Roots of AR/MA polynomials are stabilized for invertibility.

\strong{Spectrum-Constrained constructions:}
Alternating projections enforce target eigenvalues/rank/condition number while preserving diagonal.
The matrix supplied in \code{loadings} is used to generate an initial positive semi-definite matrix
for iterative projection onto the target spectrum.
Default base: a \code{dim} \eqn{\times} \code{rank_target} Vandermonde-like matrix
of sin(0 : \eqn{\pi}/2) values, scaled by 10

\strong{PSD/PD Guarantee:}
All matrices constructed by this function are guaranteed to be symmetric
and either positive semi-definite (PSD) or positive definite (PD), depending on the type and parameterization:
Supplied parameters are validated to ensure PSD/PD properties for all structures,  expect for \code{type = specConstr}.
In spectrum-constrained cases, particularly when \code{rank < dim} or user-specified \code{eigenvalues} are provided,
the matrix may be near PSD.
Before returning the matrix, the function performs a \emph{final validation step} (if \code{eigen_check = TRUE})
to verify that the output is truly PSD/PD and issues errors, warnings, or messages accordingly.
}
\examples{
# Diagonal covariance
construct_covMat(5, type = "diag", params = list(variances = 1:5))

# AR(1) correlation
construct_covMat(6, corr = TRUE, type = "AR", params = list(rho = 0.8))

# Block matrix
construct_covMat(5, type = "block", params = list(groups = c(2,3), rho = c(0.5, 0.3)))

# Factor model
L <- matrix(rnorm(10), 5, 2); psi <- rep(0.2, 5)
construct_covMat(5, type = "factor", params = list(loadings = L, psi = psi))

# Spatial correlation with Matern kernel
D <- as.matrix(dist(matrix(runif(25), ncol = 5)))
construct_covMat(5, type = "spatial",
                    params = list(distances = D, kernel = "matern", phi = 1, nu = 0.5))

# Spectrum-constrained correlation matrix
construct_covMat(4, type = "specConstr", params = list(eigenvalues = c(2,1,0.5,0.5)))

}
