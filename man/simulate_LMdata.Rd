% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulate_LMdata.r
\name{simulate_LMdata}
\alias{simulate_LMdata}
\title{Simulate Data from a Linear Regression Model}
\usage{
simulate_LMdata(
  n_rep = 1,
  sim_settings = list(),
  distr_settings = list(),
  seed = NULL
)
}
\arguments{
\item{n_rep}{Integer scalar or length-2 vector.
If a vector of length 2, the first value gives the number of
independent simulated datasets (\code{n_sim})
and the second gives the number of within-dataset iterations (\code{n_iter}).
Within a dataset, the design matrix \code{X} remains fixed
but the error terms vary across iterations,
producing different response vectors (\code{y}).
If a single value is given, it is interpreted as \code{n_sim}, with \code{n_iter = 1} (default).}

\item{sim_settings}{A named list of simulation parameters,
usually constructed via \code{\link{sim_spec}} (Default).
Common fields (all optional) for the regression models include:
\describe{
\item{n_subj}{Number of subjects (sample size here).}

\item{beta_coeff}{Regression coefficient vector.
Default: a zero vector of appropriate length.}

\item{SNR}{Target signal-to-noise ratio for IID errors.
Overrides the error variance in \code{distr_settings$error_distr}.
Set to \code{NULL} (default) to disable SNR control.}

\item{X}{Optional pre-specified design matrix.
May also be lists of length \code{n_sim} to allow dataset-specific designs.
If supplied, they override stochastic generation.}

\item{p}{Dimensions of the design matrix (including intercept).}

\item{include.Xintercept}{Logical; whether to add intercept columns in \code{X}.}

\item{orthogonalize.X}{Logical; If \code{TRUE}, the non-intercept columns of \code{X}
are orthogonalized using QR decomposition.}
}
All other components of \code{sim_settings} are ignored for regression models.}

\item{distr_settings}{A named list of distribution specifications for stochastic components.
Valid entries are: \code{error_distr} and \code{X_distr},
specifying the distributions used to generate random errors,
and the design matrix, respectively.
Each entry is itself a list with elements (see \code{\link{simulate_IIDdata}}):
\describe{
\item{distr_name}{Distribution name (e.g., \code{"norm"}, \code{"mvnorm"}, \code{"copula"}).}
\item{distr_params}{List of parameters for the specified distribution.}
\item{generator}{Optional user-supplied function for random generation,
enabling simulation from arbitrary or fully custom distributions.}
}
Missing or incomplete entries are automatically completed via
\code{\link{distr_spec}} with suitable dimension defaults.
The default distribution is multivariate normal with zero mean and identity covariance.
See @details for more on specification of the error distribution.}

\item{seed}{Optional integer.If provided, the random number generator (RNG)
state is temporarily replaced by this seed and restored upon exit.}
}
\value{
A named list (of class \code{"LMdata"}) containing:
\describe{
\item{n}{Total number of observations in each simulated dataset.}
\item{y}{List of simulated response matrices of length \code{n_sim}.
Each matrix has dimension \verb{n × n_iter}.}
\item{X}{List of design matrices of length \code{n_sim},
one per simulated dataset.}
\item{sigma_e}{List of error standard deviations (length \code{n_sim}).
Each entry is a vector of length \code{n_iter}.}
\item{SNR}{List of achieved signal-to-noise ratios (length \code{n_sim}).
Each entry is a vector of length \code{n_iter}.}
\item{sim_settings, distr_settings}{Lists of (possibly updated) simulation and
distribution settings used to generate the data.}
}
If a list has only one single element (i.e., \code{n_sim = 1} or \code{n_iter  = 1}),
it is automatically flattened.
}
\description{
Generates datasets from a Linear Model (LM)
with flexible control over design matrix,
correlation structures, and error distributions.

All stochastic components (error terms, and also design matrices if unspecified)
are generated via \link{simulate_IIDdata},
a \strong{highly general and flexible sample generator}
supporting almost all univariate and multivariate distributions.

The function supports general, possibly correlated and/or heteroscedastic,
error distributions. When the error distribution \emph{is}
independent and identically distributed (\strong{IID}, meaning all error terms share
the same distribution and are mutually independent),
users may specify a target signal-to-noise ratio (SNR).
In this case, the error variance is automatically scaled to match the desired SNR.
SNR control is not supported for non-IID errors.
}
\details{
\strong{Construction of the design matrix.}
\itemize{
\item If \code{sim_settings$X} is supplied: \code{X} is used exactly as provided
and its column dimension updates \code{p}.
\item If \code{X} is not supplied: \code{X} is generated using \code{distr_settings$X_distr}.
\item Intercepts are added \strong{after} stochastic generation, if requested.
\item Orthogonalization of non-intercept columns is performed last
using the \code{\link[base]{qr}} function.
}

\strong{Error distribution specification}
The error distribution (\code{error_distr}) may be:
\itemize{
\item \strong{Univariate} with scalar \code{sigma},
which corresponds to IID errors.

\item \strong{Multivariate}, with a covariance matrix \code{sigma}
of dimension equal to the total number of observations,
enabling arbitrary correlation and heteroscedasticity.
}
IID errors can also be represented through a multivariate specification
with diagonal covariance matrix in \code{sigma}.
If \code{sigma} is not specified in \code{error_distr$distr_params},
a default IID specification is constructed.

\strong{SNR control}
When \code{SNR} is supplied and the error distribution is IID,
the error variance is automatically scaled to achieve
the target signal-to-noise ratio
(defined as the ratio of variances of signals and errors).
SNR control is not supported for non-IID errors.

\strong{Dependencies}
Certain distribution choices (e.g., copulas) may require additional packages.
See \code{\link{simulate_IIDdata}} for details on required packages
and supported distributions.
}
\examples{

# Basic simulation
set.seed(123)
sim1 <- simulate_LMdata()
str(sim1, max.level = 1)


# Multiple replications and iterations
sim <- simulate_LMdata(n_rep = c(2, 3)) # 2 reps × 3 iterations
length(sim$y)         # 2 replications
dim(sim$y[[1]])       # 50 × 3 iterations (default sample size 50)


# Non-Gaussian error and multivariate predictors
distr_settings <- list(
  error_distr = list(distr_name = "t", distr_params = distr_spec(df = 4)),
  X_distr    = list(distr_name = "mvtnorm::rmvnorm", distr_params = list(dim = 2, sigma = diag(2)))
)
sim <- simulate_LMdata(
  n_rep = 1,
  sim_settings = sim_spec(n_subj = 15),
  distr_settings = distr_settings
)

# User-supplied design matrices
n_subj <- 10
n <- n_subj
X_user <- matrix(rnorm(n*3), ncol=3)
Z_user <- matrix(rnorm(n*2), ncol=2)
sim_settings <- sim_spec(n_subj = n_subj, X = X_user, Z = Z_user,
                          beta_coeff = c(1,0.5,-1))
sim <- simulate_LMdata(sim_settings = sim_settings)


# Copula-based generation
if (requireNamespace("copula", quietly = TRUE)) {
library(copula)
normal_cop <- normalCopula(param = 0.6, dim = 2)
distr_settings <- list(
  X_distr = list(
    distr_name = "copula",
    distr_params = distr_spec(
      copula = normal_cop,
      margins = list(
        list(dist="norm", params=list(mean=0, sd=1)),
        list(dist="norm", params=list(mean=0, sd=2))
      )
    )
  )
)
sim <- simulate_LMdata(sim_settings = sim_spec(n_subj = 10),
                         distr_settings = distr_settings)
plot(sim$X[,2:3], main = "X from Copula-based distribution")
}

}
\seealso{
\code{\link{simulate_IIDdata}}, \code{\link{distr_spec}}, \code{\link{sim_spec}}.
Also \code{\link{summary.LMdata}}, \code{\link{print.LMdata}}, \code{\link{plot.LMdata}}
for S3 methods applicable to the returned object
}
